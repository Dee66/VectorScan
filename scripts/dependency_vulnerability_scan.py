#!/usr/bin/env python3
"""Dependency vulnerability scanner using OSV for VectorScan."""
from __future__ import annotations

import argparse
import dataclasses
import importlib.metadata as metadata
import json
import re
import sys
import urllib.error
import urllib.request
from pathlib import Path
from typing import Dict, Iterable, List, Optional, Sequence


OSV_QUERY_URL = "https://api.osv.dev/v1/querybatch"

EXIT_OK = 0
EXIT_INVALID_INPUT = 2
EXIT_VULNERABILITIES_FOUND = 3
EXIT_OSV_ERROR = 4

NAME_PATTERN = re.compile(r"^[A-Za-z0-9_.-]+")


@dataclasses.dataclass
class PackageSpec:
    name: str
    version: str
    source: Path


def _parse_requirement_line(line: str) -> Optional[str]:
    stripped = line.split("#", 1)[0].strip()
    return stripped or None


def _extract_requirement(entry: str) -> Optional[Dict[str, str]]:
    if entry.startswith("-r "):
        target = entry[3:].strip()
        if not target:
            raise ValueError("-r directive must include a path")
        return {"include": target}

    match = NAME_PATTERN.match(entry)
    if not match:
        return None
    name = match.group(0)
    spec = entry[match.end() :].strip()
    return {"name": name, "spec": spec}


def _resolve_version(name: str, spec: str) -> Optional[str]:
    if spec.startswith("=="):
        version = spec[2:].strip()
        return version or None

    # For non-pinned specs, fallback to the installed version.
    try:
        return metadata.version(name)
    except metadata.PackageNotFoundError:
        return None


def _collect_packages(requirement_paths: Sequence[Path]) -> List[PackageSpec]:
    collected: Dict[str, PackageSpec] = {}
    visited: set[Path] = set()

    def _walk(path: Path) -> None:
        normalized = path.resolve()
        if normalized in visited:
            return
        if not normalized.is_file():
            raise FileNotFoundError(f"requirements file not found: {path}")
        visited.add(normalized)

        for raw_line in normalized.read_text().splitlines():
            entry = _parse_requirement_line(raw_line)
            if not entry:
                continue
            parsed = _extract_requirement(entry)
            if not parsed:
                continue
            if "include" in parsed:
                include_path = (normalized.parent / parsed["include"]).resolve()
                _walk(include_path)
                continue

            version = _resolve_version(parsed["name"], parsed["spec"])
            if not version:
                raise ValueError(
                    f"Unable to resolve version for {parsed['name']} (spec='{parsed['spec'] or 'unspecified'}')"
                )
            key = parsed["name"].lower()
            collected[key] = PackageSpec(name=parsed["name"], version=version, source=normalized)

    for requirement in requirement_paths:
        _walk(requirement)

    return list(collected.values())


def _query_osv(payload: Dict[str, object]) -> Dict[str, object]:
    encoded = json.dumps(payload).encode("utf-8")
    request = urllib.request.Request(OSV_QUERY_URL, data=encoded, headers={"Content-Type": "application/json"})
    try:
        with urllib.request.urlopen(request, timeout=30) as response:
            data = response.read().decode("utf-8")
    except urllib.error.URLError as exc:
        raise RuntimeError(f"network error when querying OSV: {exc}") from exc
    return json.loads(data)


def _build_payload(packages: Iterable[PackageSpec]) -> Dict[str, object]:
    return {
        "queries": [
            {
                "package": {"ecosystem": "PyPI", "name": pkg.name},
                "version": pkg.version,
            }
            for pkg in packages
        ]
    }


def _extract_findings(packages: Sequence[PackageSpec], response: Dict[str, object]) -> List[Dict[str, str]]:
    findings: List[Dict[str, str]] = []
    results = response.get("results")
    if not isinstance(results, list):
        raise ValueError("OSV response missing 'results'")

    for pkg, result in zip(packages, results, strict=False):
        vulns = result.get("vulns") if isinstance(result, dict) else None
        if not vulns:
            continue
        for vuln in vulns:
            severity = None
            sev = vuln.get("severity") if isinstance(vuln, dict) else None
            if isinstance(sev, list) and sev:
                severity = sev[0].get("score") or sev[0].get("type")
            findings.append(
                {
                    "package": pkg.name,
                    "version": pkg.version,
                    "id": vuln.get("id", "UNKNOWN"),
                    "summary": (vuln.get("summary") or "").strip(),
                    "severity": severity or "UNKNOWN",
                }
            )
    return findings


def _print_text(findings: Sequence[Dict[str, str]]) -> None:
    if not findings:
        print("No known vulnerabilities detected via OSV.")
        return
    print("Detected vulnerabilities:\n")
    for finding in findings:
        print(f"- {finding['package']}=={finding['version']} | {finding['id']} | {finding['severity']}")
        if finding["summary"]:
            print(f"  {finding['summary']}")


def _parse_args(argv: Optional[Sequence[str]] = None) -> argparse.Namespace:
    parser = argparse.ArgumentParser(description="Scan requirements against OSV without external deps.")
    parser.add_argument(
        "--requirements",
        nargs="*",
        type=Path,
        default=[Path("requirements.txt"), Path("requirements-dev.txt")],
        help="Requirement file paths to scan (default: requirements.txt requirements-dev.txt)",
    )
    parser.add_argument(
        "--format",
        choices=("text", "json"),
        default="text",
        help="Output format",
    )
    return parser.parse_args(argv)


def main(argv: Optional[Sequence[str]] = None) -> int:
    args = _parse_args(argv)

    try:
        packages = _collect_packages(args.requirements)
    except (FileNotFoundError, ValueError) as exc:
        print(f"dependency-scan: {exc}", file=sys.stderr)
        return EXIT_INVALID_INPUT

    if not packages:
        print("dependency-scan: no packages resolved", file=sys.stderr)
        return EXIT_OK

    payload = _build_payload(packages)
    try:
        response = _query_osv(payload)
    except RuntimeError as exc:
        print(f"dependency-scan: {exc}", file=sys.stderr)
        return EXIT_OSV_ERROR

    findings = _extract_findings(packages, response)

    if args.format == "json":
        print(json.dumps({"findings": findings}, indent=2))
    else:
        _print_text(findings)

    return EXIT_VULNERABILITIES_FOUND if findings else EXIT_OK


if __name__ == "__main__":
    raise SystemExit(main())
