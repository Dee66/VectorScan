"""Generate placeholder internal APIs required by the Copilot checklist.

VectorScan's Copilot flow must be able to regenerate missing internal APIs on
command. This module keeps the canonical templates and can either create or
verify the stubbed modules.
"""
from __future__ import annotations

import argparse
import textwrap
from dataclasses import dataclass
from pathlib import Path
from typing import List, Sequence

_REPO_ROOT = Path(__file__).resolve().parents[2]


@dataclass(frozen=True)
class APIStub:
    """Properties describing a stub file."""

    relative_path: Path
    template: str


@dataclass
class StubReport:
    """Result of running the stub generator."""

    created: List[Path]
    updated: List[Path]
    missing: List[Path]


_STUB_TEMPLATES = {
    "tools/vectorscan/api_stubs/__init__.py": textwrap.dedent(
        '''"""Autogenerated API stub package for Copilot flows."""
from __future__ import annotations

from .lead_capture import LeadCaptureClient
from .telemetry import TelemetryClient
from .terraform_adapter import TerraformAdapter

__all__ = ["LeadCaptureClient", "TelemetryClient", "TerraformAdapter"]
'''
    ),
    "tools/vectorscan/api_stubs/lead_capture.py": textwrap.dedent(
        '''"""Stub lead capture client for Copilot-generated flows."""
from __future__ import annotations

from dataclasses import dataclass, field
from typing import Any, List


@dataclass
class LeadCaptureClient:
    """Stores all capture payloads locally for later inspection."""

    captures: List[dict[str, Any]] = field(default_factory=list)

    def capture(self, email: str, payload: dict[str, Any]) -> None:
        record: dict[str, Any] = {"email": email, "payload": payload}
        self.captures.append(record)

    def last_capture(self) -> dict[str, Any] | None:
        return self.captures[-1] if self.captures else None
'''
    ),
    "tools/vectorscan/api_stubs/telemetry.py": textwrap.dedent(
        '''"""Stub telemetry client for Copilot-generated flows."""
from __future__ import annotations

from dataclasses import dataclass, field
from typing import Any, Dict, List, Tuple


@dataclass
class TelemetryClient:
    """Collects emitted metrics in-memory for deterministic testing."""

    metrics: List[Tuple[str, float, dict[str, Any]]] = field(default_factory=list)

    def emit(self, metric: str, value: float, tags: dict[str, Any] | None = None) -> None:
        self.metrics.append((metric, value, tags or {}))

    def clear(self) -> None:
        self.metrics.clear()
'''
    ),
    "tools/vectorscan/api_stubs/terraform_adapter.py": textwrap.dedent(
        '''"""Stub Terraform adapter for Copilot-generated flows."""
from __future__ import annotations

from dataclasses import dataclass
from typing import Any


@dataclass
class TerraformAdapter:
    """Provides deterministic terraform test results without running terraform."""

    binary: str = "terraform"
    version: str = "default"

    def run_tests(self, working_dir: str) -> dict[str, Any]:
        return {
            "status": "SKIP",
            "working_dir": working_dir,
            "version": self.version,
            "binary": self.binary,
            "stdout": "terraform tests skipped in stub",
            "stderr": "",
        }
'''
    ),
}

_STUBS: tuple[APIStub, ...] = tuple(
    APIStub(Path(path), template) for path, template in sorted(_STUB_TEMPLATES.items())
)


def ensure_stubs(base_path: Path, apply_changes: bool = True) -> StubReport:
    created: List[Path] = []
    updated: List[Path] = []
    missing: List[Path] = []

    for stub in _STUBS:
        target = base_path / stub.relative_path
        if not target.exists():
            if apply_changes:
                target.parent.mkdir(parents=True, exist_ok=True)
                target.write_text(stub.template, encoding="utf-8")
                created.append(target)
            else:
                missing.append(target)
            continue

        current = target.read_text(encoding="utf-8")
        if current == stub.template:
            continue
        if apply_changes:
            target.write_text(stub.template, encoding="utf-8")
            updated.append(target)
        else:
            missing.append(target)

    return StubReport(created=created, updated=updated, missing=missing)


def _parse_args(argv: Sequence[str] | None = None) -> argparse.Namespace:
    parser = argparse.ArgumentParser(description="Ensure Copilot API stubs exist.")
    parser.add_argument(
        "--base-path",
        type=Path,
        default=_REPO_ROOT,
        help="Repository root. Defaults to project root detected from this file.",
    )
    parser.add_argument(
        "--check",
        action="store_true",
        help="Verify stub files are up to date without writing.",
    )
    return parser.parse_args(argv)


def main(argv: Sequence[str] | None = None) -> int:
    args = _parse_args(argv)
    report = ensure_stubs(args.base_path.resolve(), apply_changes=not args.check)
    if args.check:
        if report.missing:
            print("Out-of-date API stub files:")
            for path in report.missing:
                print(f" - {path.relative_to(args.base_path)}")
            return 1
        print("All API stub files are up to date.")
        return 0

    if not report.created and not report.updated:
        print("API stubs already satisfied.")
        return 0

    if report.created:
        print("Created API stubs:")
        for path in report.created:
            print(f" - {path.relative_to(args.base_path)}")
    if report.updated:
        print("Updated API stubs:")
        for path in report.updated:
            print(f" - {path.relative_to(args.base_path)}")
    return 0


if __name__ == "__main__":  # pragma: no cover
    raise SystemExit(main())
