"""Generate deterministic pytest suites for the Copilot checklist.

The Copilot Generation checklist expects automated creation of a minimal yet
real pytest suite that exercises the CLI end to end. This module produces those
suites so they can be regenerated deterministically (similar to how
`copilot_scaffolder` keeps fixtures and goldens in sync).
"""
from __future__ import annotations

import argparse
from dataclasses import dataclass
from pathlib import Path
from typing import List, Sequence

REPO_ROOT = Path(__file__).resolve().parents[2]


@dataclass(frozen=True)
class SuiteFile:
    """Description of an autogenerated pytest module."""

    relative_path: Path
    template: str


CLI_SMOKE_TEMPLATE = '''"""Autogenerated CLI smoke tests (do not edit manually).

These tests are intentionally lightweight but exercise the CLI against the
canonical fixtures so Copilot can regenerate them on demand. Regenerate via:
    python3 tools/vectorscan/copilot_suite_generator.py
"""
from __future__ import annotations

import json
import os
import subprocess
import sys
from pathlib import Path

import pytest

REPO_ROOT = Path(__file__).resolve().parents[2]
CLI_PATH = REPO_ROOT / "tools" / "vectorscan" / "vectorscan.py"
FIXTURES = REPO_ROOT / "tests" / "fixtures"


def _run_cli(fixture_name: str, *flags: str) -> subprocess.CompletedProcess[str]:
    fixture_path = FIXTURES / fixture_name
    assert fixture_path.exists(), fixture_path
    env = os.environ.copy()
    env.setdefault("VSCAN_OFFLINE", "1")
    env.setdefault("VSCAN_CLOCK_ISO", "2024-01-01T00:00:00Z")
    env.setdefault("VSCAN_CLOCK_EPOCH", "1704067200")
    env.setdefault("VSCAN_NO_COLOR", "1")
    cmd = [sys.executable, str(CLI_PATH), str(fixture_path), *flags]
    return subprocess.run(cmd, capture_output=True, text=True, check=False, env=env)


def test_pass_fixture_returns_zero() -> None:
    result = _run_cli("tfplan_pass.json", "--json")
    assert result.returncode == 0, result.stderr
    payload = json.loads(result.stdout)
    assert payload["status"] == "PASS"
    assert payload["metrics"]["compliance_score"] == pytest.approx(100.0)


def test_fail_fixture_returns_three() -> None:
    result = _run_cli("tfplan_fail.json", "--json")
    assert result.returncode == 3, result.stdout
    payload = json.loads(result.stdout)
    assert payload["status"] == "FAIL"
    violations_struct = payload.get("violations_struct", [])
    assert any(v.get("policy_id") == "P-SEC-001" for v in violations_struct)
'''


SUITE_FILES: tuple[SuiteFile, ...] = (
    SuiteFile(Path("tests/copilot_generated/test_cli_smoke.py"), CLI_SMOKE_TEMPLATE),
)


@dataclass
class SuiteReport:
    created: List[Path]
    updated: List[Path]
    mismatched: List[Path]


def ensure_suites(base_path: Path, apply_changes: bool = True) -> SuiteReport:
    created: List[Path] = []
    updated: List[Path] = []
    mismatched: List[Path] = []

    for suite in SUITE_FILES:
        target = base_path / suite.relative_path
        if not target.exists():
            if apply_changes:
                target.parent.mkdir(parents=True, exist_ok=True)
                target.write_text(suite.template, encoding="utf-8")
                created.append(target)
            else:
                mismatched.append(target)
            continue

        current = target.read_text(encoding="utf-8")
        if current == suite.template:
            continue

        if apply_changes:
            target.write_text(suite.template, encoding="utf-8")
            updated.append(target)
        else:
            mismatched.append(target)

    return SuiteReport(created=created, updated=updated, mismatched=mismatched)


def _parse_args(argv: Sequence[str] | None = None) -> argparse.Namespace:
    parser = argparse.ArgumentParser(description="Generate Copilot pytest suites.")
    parser.add_argument(
        "--base-path",
        type=Path,
        default=REPO_ROOT,
        help="Repository root (defaults to project root).",
    )
    parser.add_argument(
        "--check",
        action="store_true",
        help="Verify suites are up to date without writing files.",
    )
    return parser.parse_args(argv)


def main(argv: Sequence[str] | None = None) -> int:
    args = _parse_args(argv)
    base_path = args.base_path.resolve()
    report = ensure_suites(base_path, apply_changes=not args.check)

    if args.check:
        if report.mismatched:
            print("Out-of-date Copilot suites:")
            for path in report.mismatched:
                print(f" - {path.relative_to(base_path)}")
            return 1
        print("All Copilot suites are up to date.")
        return 0

    if not report.created and not report.updated:
        print("Copilot suites already in sync.")
        return 0

    if report.created:
        print("Created suites:")
        for path in report.created:
            print(f" - {path.relative_to(base_path)}")
    if report.updated:
        print("Updated suites:")
        for path in report.updated:
            print(f" - {path.relative_to(base_path)}")
    return 0


if __name__ == "__main__":  # pragma: no cover - exercised via CLI usage
    raise SystemExit(main())
